---
title: "Week 8 - SQL Injection Point Analysis and Mitigation Techniques"
date: 2025-06-03
categories: [study]
layout: single
author_profile: true
sidebar:
  nav: "main"
read_time: true
toc: true
toc_label: "On this page"
toc_sticky: true
---

# Finding SQL Injection Point

Today’s topic focuses on identifying where SQL Injection can occur.

As mentioned in other posts, SQL Injection (SQLi) can be divided into three main types:
- Union-based SQL Injection
- Error-based SQL Injection
- Blind SQL Injection

The ultimate goal of all three is to retrieve data from the server's database by executing SQL SELECT statements.
Among these, Blind SQL Injection can be used in almost any situation where SQLi is possible. However, it's relatively slow and cumbersome, so it's important to choose the most efficient method for the situation.

### How to find Injection Points

To locate SQL Injection points, you need to find where there’s interaction between user input and the database. Web pages often include static data—like the site title, which is hardcoded in HTML—or dynamic data fetched from the database.

Common dynamic interaction points include:
- Bulletin boards (forums)
- Login pages
- Sign-up pages

SQL queries like INSERT, SELECT, and more will be used in such places.
Rather than blindly injecting ' OR '1'='1, it's critical to first analyze the SQL query that might be executed and then inject

When crafting SQLi payloads:
```
Always have a reason for injecting specific values.
Avoid using SQL comments (--, #) in complex targets.
These may prevent the query from executing correctly if the system handles queries differently.
```

Let’s look at a few case studies.


## 1. Cookie-Based SQL Injection

![image](https://github.com/user-attachments/assets/aadb8b00-e263-4808-bc51-01ffe6129bf5)
My Page view when cookie = jimin 

In this case, we try manipulating the user cookie value to determine if it can influence the SQL query.

We hypothesize the server-side query looks like:
```
$username = $_COOKIE['user'];
$result = mysqli_query($conn, "SELECT * FROM table_name WHERE id = '$username'");
When the cookie is jimin, the query becomes:
SELECT * FROM table_name WHERE id = 'jimin';
```
We assume that the page's output depends on whether result contains a row (i.e., num_rows > 0).
Now, We can try injecting:
- 'jimin' and '1'='1 → should return the same result as 'jimin'
- 'jimin' and '1'='2 → should return nothing if it's evaluated as false

![image](https://github.com/user-attachments/assets/20c0386b-86c5-46bd-b690-1c49f91768f1)
Injection with '1'='1 returns normal page

![image](https://github.com/user-attachments/assets/0336d114-4a9c-4cb0-b030-61853b197600)
Injection with '1'='2 removes the “Nothing Here...” message

From this, we confirm that different responses occur depending on true/false conditions in the SQL query. Hence, there is an SQL Injection vulnerability.



## 2. Column Name-Based SQL Injection

There is a feature in the forum that lets users search or sort based on specific columns.
At this point, the value included in the URL or POST parameter is used in place of a column name in the SQL query.
![image](https://github.com/user-attachments/assets/766b3eb2-6d26-4f6f-8b16-bbff9523d951)

Now, let’s once again try to predict the SQL query just like we did in section 1.
Since this is a forum, it will likely use a SELECT statement to show posts to users.
Let’s imagine how the parameter board_result=test will be incorporated into the query.
Usually, the query applies a LIKE clause to the input to display only posts that contain the entered keyword.
In other words, we can assume a structure like:
```
SELECT * FROM table_name WHERE [option_val] LIKE '%[board_result]%';
```

Now that we’ve identified a suspicious input point, let’s try inserting different values to determine whether SQL Injection is truly possible.


![image](https://github.com/user-attachments/assets/274a1ca4-864c-4068-82d3-0da58cec341b)
We inserted ('1'='1') and test into option_val.
The expected SQL query would look like:
```
SELECT * FROM table_name WHERE ('1'='1') and test LIKE '%[board_result]%';
```
Since the forum displays results normally,
we can assume the value we inserted is being used in the query.
Now let’s try a false case to differentiate between true and false.

![image](https://github.com/user-attachments/assets/022f7182-861d-4eee-8400-67b6e2885893)
As expected, after inserting ('1'='2') and test into option_val, it evaluates as false and no posts are displayed.


## 3. ORDER BY 절 SQL Injection

![image](https://github.com/user-attachments/assets/c41eb75b-6bbc-4e6e-831c-fa778ad024ce)
위 2가지 방식과 동일하게 우선 서버 내의 sql 쿼리를 Burp Suite를 통해 유추해보자
```
option_val=title&board_result=oliver&board_search=%F0%9F%94%8D&date_from=&date_to=&sort=title
```
이 문장에서 우리가 주목해야할 파라미터는 option_val, board_result, 마지막으로 sort일것이다.
아까 option_val는 column board_result는 like절 안에 들어가는 변수값에 들어간다는것을 대략적으로 파악했다. 이제 sort는 어느방식으로 사용되는지 유추해보아야 할것이다.


![image](https://github.com/user-attachments/assets/c748727f-2ab8-44fa-8664-dfdf320377e2)
sort=10을 보냈을때 게시판이 정상적으로 출력된다

![image](https://github.com/user-attachments/assets/0bcab527-4c26-464f-a88e-a02c19e5d004)
sort=11을 보내니 게시판이 출력되지 않는다.

이로써 sort에 넣는 값은 order by []에 들어가는 값이라고 예측가능하다 이유는 order by에서 index num은 컬럼의 개수를 넘으면 오류가 발생하는데 sort가 그 index num이라고 동일시 할 수 있기 때문이다.

따라서 sql 쿼리는  다음과 같이 예상할 수 있다.
```
SELECT * FROM 테이블 이름
WHERE [option_val]
LIKE '%[board_result]%'
order by [sort];
```
자 이제 sort는 order by 절에 들어가는 값이라고 정했다. 그럼 이제 sort를 이용해 참 / 거짓을 어떻게 구별해야할까? 

### case when
```
format: case when (조건) then (참일때) else (거짓일 때) end
ex: case when (1=1) then 1 else 2 end 
    -> 1 
    case when (1=2) then 1 else 2 end 
    ->2 
```
이 case when 문법을 이용해 우리는 sort의 값을 변화시켜 참 거짓을 구별할 수 있을것이다

![image](https://github.com/user-attachments/assets/27270259-3f34-4e22-bb38-047d74feb559)

![image](https://github.com/user-attachments/assets/3995c268-6a7b-49ea-92c0-b44028539c50)
```
&sort=case when (1=1) then username else title end 

-> 참이면 username 

&sort=case when (1=2) then username else title end 

-> 거짓이면 title
```



​하지만 위 방법대로 하기엔 username / title이 올바른 컬럼네임이라고 확정할 수 없기에
아래와같이 에러를 유발하는 방법을 사용할 수 있다.
```
sort=case when (1=1) then 1  > 참일 때 첫번째 컬럼으로 정렬하고 
else (select 1 union select 2) end  > 거짓일 때 첫번째와 두번째 컬럼으로 정렬
```

만약 (1=1)로 참이라면 sort값은 1로 order by 1이 되어 서버는 첫번째 컬럼으로 게시글을 정렬할것이고 (1=2)로 거짓이라면 sort값은 1과 2를 동시에 선택 order by는 첫번째 두번째 컬럼으로 정렬을 해버리는것이기때문에 오류가 발생한다.
일부로 오류를 발생시키는 이유는 우리는 서버 DB의 컬럼수도, 컬럼명도 모르기에 에러를 유발하여 참과 거짓의 결과값을 구분하는것이다.

## 4. DB Error

인젝션 포인트를 검사하기 위해 참/거짓조건을 넣어도 변화를 발견할 수 없는 경우
문법에러를 유도하여 (예 싱글쿼터 등 )  디비에러가 반환되는 경우 에러를 일부러 만들어야 하는 상황이 있다.

```
user=jimin' and (select 1 union select 2 where (1=2)) and '1'='1;
```
위의 값을 user에 대입해보자
![image](https://github.com/user-attachments/assets/52893605-d928-4d56-92d0-57c1b5f22718)
문제없이 페이지가 출력된다 

이때 where (1=2)를 where (1=1)로 바꾸어보자
![image](https://github.com/user-attachments/assets/5ed4fb6a-8c06-490f-b3b8-5907691e78fd)
DB에러가 발생한다.

즉 1=1일 때는 SELECT 1 UNION SELECT 2로 인해 두 개의 row가 반환되며,
단일 값을 기대하는 SQL 문에서는 문법 오류가 발생한다.
이때 발생한 SQL 에러를 통해 Blind SQL Injection의 참/거짓 판별이 가능하다.



## 5. sql 인젝션 대응 방안

### 5.1 Prepared Statement 
SQL 쿼리 문장을 미리 컴파일해두고, 사용자 입력값만 나중에 채우는 방식이다.
쿼리 구조와 입력값이 철저히 분리되기 때문에 입력값이 쿼리 구조에 영향을 줄 수 없음.

```
01001001001_________01101010
→ 고정된 틀에 입력값만 채우는 것
```

장점
- SQL Injection을 근본적으로 차단할 수 있음
- 쿼리 구조 자체가 변경되지 않음

Prepared Statement가 있음에도 SQL Injection을 배우는 이유
- Prepared Statement를 잘못 쓰는 경우
예: 문자열 연결로 쿼리 조립
```
"SELECT * FROM users WHERE id = " . $_GET['id']
Prepared Statement를 아예 쓸 수 없는 경우
```

- ORDER BY절 / 테이블이름 / 컬럼이름 이 3곳에서는 사용이 불가능하다.
   이 경우는 Prepared Statement로 보호할 수 없음

 ### 5.2 화이트리스트 기반 필터링

- 화이트 기반 필터링
    : 특정 단어만 쓸 수 있게 하는 것.
예시:
```
$sort = $_GET['sort'];

if ($sort == 'title' || $sort == 'username') {
    $query = "SELECT * FROM board ORDER BY $sort";
} else {
     echo "허용되지 않은 정렬 방식입니다.";
     exit;
}
➡ title, date만 허용. 그 외 입력은 차단.
```
- 블랙리스트 필터링
금지된 단어만 막는 방식



